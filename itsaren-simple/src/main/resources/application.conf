akka {
  loglevel = INFO
  event-handlers = ["akka.event.slf4j.Slf4jEventHandler"]

  http {
    server {
      # The time after which an idle connection will be automatically closed.
      # Set to `infinite` to completely disable idle connection timeouts. 60 s
      idle-timeout = 30s

      # Defines the default time period within which the application has to
      # produce an HttpResponse for any given HttpRequest it received.
      # The timeout begins to run when the *end* of the request has been
      # received, so even potentially long uploads can have a short timeout.
      # Set to `infinite` to completely disable request timeout checking.
      #
      # If this setting is not `infinite` the HTTP server layer attaches a
      # `Timeout-Access` header to the request, which enables programmatic
      # customization of the timeout period and timeout response for each
      # request individually.
      request-timeout = 20s

      # The maximum number of concurrently accepted connections when using the
      # `Http().bindAndHandle` methods.
      #
      # This setting doesn't apply to the `Http().bind` method which will still
      # deliver an unlimited backpressured stream of incoming connections.
      #
      # Note, that this setting limits the number of the connections on a best-effort basis.
      # It does *not* strictly guarantee that the number of established TCP connections will never
      # exceed the limit (but it will be approximately correct) because connection termination happens
      # asynchronously. It also does *not* guarantee that the number of concurrently active handler
      # flow materializations will never exceed the limit for the reason that it is impossible to reliably
      # detect when a materialization has ended.
      max-connections = 1024

      # The maximum number of requests that are accepted (and dispatched to
      # the application) on one single connection before the first request
      # has to be completed.
      # Incoming requests that would cause the pipelining limit to be exceeded
      # are not read from the connections socket so as to build up "back-pressure"
      # to the client via TCP flow control.
      # A setting of 1 disables HTTP pipelining, since only one request per
      # connection can be "open" (i.e. being processed by the application) at any
      # time. Set to higher values to enable HTTP pipelining.
      # This value must be > 0 and <= 1024. 16
      pipelining-limit = 1024

      # The requested maximum length of the queue of incoming connections.
      # If the server is busy and the backlog is full the OS will start dropping
      # SYN-packets and connection attempts may fail. Note, that the backlog
      # size is usually only a maximum size hint for the OS and the OS can
      # restrict the number further based on global limits.
      backlog = 100
    }

    host-connection-pool {
      # The maximum number of parallel connections that a connection pool to a
      # single host endpoint is allowed to establish. Must be greater than zero.
      max-connections = 128

      # The maximum number of open requests accepted into the pool across all
      # materializations of any of its client flows.
      # Protects against (accidentally) overloading a single pool with too many client flow materializations.
      # Note that with N concurrent materializations the max number of open request in the pool
      # will never exceed N * max-connections * pipelining-limit.
      # Must be a power of 2 and > 0!
      max-open-requests = 1024

      # The maximum number of requests that are dispatched to the target host in
      # batch-mode across a single connection (HTTP pipelining).
      # A setting of 1 disables HTTP pipelining, since only one request per
      # connection can be "in flight" at any time.
      # Set to higher values to enable HTTP pipelining.
      # This value must be > 0.
      # (Note that, independently of this setting, pipelining will never be done
      # on a connection that still has a non-idempotent request in flight.
      #
      # Before increasing this value, make sure you understand the effects of head-of-line blocking.
      # Using a connection pool, a request may be issued on a connection where a previous
      # long-running request hasn't finished yet. The response to the pipelined requests may then be stuck
      # behind the response of the long-running previous requests on the server. This may introduce an
      # unwanted "coupling" of run time between otherwise unrelated requests.
      #
      # See http://tools.ietf.org/html/rfc7230#section-6.3.2 for more info.) 1
      pipelining-limit = 1024
    }

    # Modify to tweak default parsing settings.
    #
    # IMPORTANT:
    # Please note that this sections settings can be overriden by the corresponding settings in:
    # `akka.http.server.parsing`, `akka.http.client.parsing` or `akka.http.host-connection-pool.client.parsing`.
    parsing {

      # Default maximum content length which should not be exceeded by incoming request entities.
      # Can be changed at runtime (to a higher or lower value) via the `HttpEntity::withSizeLimit` method.
      # Note that it is not necessarily a problem to set this to a high value as all stream operations
      # are always properly backpressured.
      # Nevertheless you might want to apply some limit in order to prevent a single client from consuming
      # an excessive amount of server resources.
      #
      # Set to `infinite` to completely disable entity length checks. (Even then you can still apply one
      # programmatically via `withSizeLimit`.)
      max-content-length = 1m
    }
  }
}
